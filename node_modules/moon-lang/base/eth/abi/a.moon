//type
  //= String
  //| Bytes Num
  //| Uint Num

arrayLength = zb2rhj31DmWEQi2c9stdR1r8wfFboPeFCEdXNysWKikEx3QHy
arrayMap = zb2rhgW1F8GpBDCtoXjEcqDBFXNiCDaPNt1fekX2Po8uHWiEV
arrayGet = zb2rhjfCUgfysNDVs2pTuMw9Um8hRbGyYdsjKCaMTceKAGDSG
arraySlice = zb2rhiPF8JLJ2JFUKR3MGk8HvdjSSa6oAY7KmVpXzZfcD65zu
arrayAny = zb2rhgMZj9zo2uedSAd59429jtEuTVESMmwYkZesbpH8d2S92

strFilter = zb2rhnhgfZ8ynnFW7WtAuQvU23Z6Bt5UxYCVx8usrjt1m8VSu
strSplit = zb2rheqi4ntPSJQnoW8aCC7x9ydG5WBAM2dtDsQ9fDjkp36ek

bytesLength = zb2rhbRAVvyLUE9tCysrnWvP7guviTgXQWzcK41KocGrhnvnH
bytesConcat = zb2rhd8xzKmJPH4H4D8SABF547bcJy2P5ze7hmPEHJz2Pnp7N
bytesPad = zb2rharxQTRobPCL5Qhy6LaWTWo7LsYJ63rVzqjDrk3hArS8T
bytesFromHex = zb2rhnRAXG8KJ9FAwVTmW7qrfcMuWVJcnKNb5qSBe3sp2r9JS

u16ToBig = zb2rhYRhv5qo5sPoXSkH34uT4tRxpFDnNkc6G5BDW6pDEk3TW
bigToHex = zb2rhZFXk2vLZmHXnJ3VCsZfRXjDfSEi3o2fUT6g2iC7wecGU

isDynamic = type =>
  name = (get type "name")
  dims = (get type "dims")
  (arrayAny (eql 1) [
    (cmp name "bytes")
    (cmp name "string")
    (arrayAny (eql 0) dims)
  ])

parseType = str =>
  notClosingBracket = char => (sub 1 (cmp char "]"))
  strs = (strSplit "[" (strFilter notClosingBracket str))
  name = (get strs "0")
  dims = (arrayMap (stn) (arraySlice strs 1 (arrayLength strs)))
  {
    name: name
    dims: dims
  }
// (isTuple : Bool) -> (if isTuple [(Type,Term)] (Type,Term)) -> Bytes
encode = encode @ isTuple => args =>

  encodeBytes32 = hex =>
    (bytesPad 0 32 "0x00" (bytesFromHex hex))

  encodeUint256 = big =>
    (encodeBytes32 (bigToHex big))

  encodeBytes = bytes =>
    length = (bytesLength bytes)
    nextMul32 = (mul (add (flr (div (sub length 1) 32)) 1) 32)
    lengthEncoded = (encodeUint256 (u16ToBig length))
    bytesEncoded = (bytesPad 1 nextMul32 "0x00" bytes)
    (bytesConcat lengthEncoded bytesEncoded)

  encodeTuple = tuple =>
    size = (arrayLength tuple)
    state = {head:"0x" tail:"0x"}
    result = (for 0 size state i => state => 
      head = (get state "head")
      tail = (get state "tail")
      pair = (arrayGet tuple i)
      type = (get pair "0")
      term = (get pair "1")
      (if (isDynamic type)
        {
          head:
            tailPos = (add (mul size 32) (bytesLength tail))
            (bytesConcat head (encodeUint256 (u16ToBig tailPos)))
          tail: (bytesConcat tail (encode 0 [type term]))
        }
        {
          head: (bytesConcat head (encode 0 [type term]))
          tail: tail
        }))
    (bytesConcat
      (get result "head")
      (get result "tail"))

  encodeTerm = type => term =>
    name = (get type "name")
    (if (cmp name "bytes32")
      (encodeBytes32 term)
      (if (cmp name "uint256")
        (encodeUint256 term)
        (if (cmp name "bytes")
          (encodeBytes term)
          "unsupported_type")))

  encodeArray = type => terms =>
    name = (get type "name")
    dims = (get type "dims")
    dim = (arrayGet dims (sub (arrayLength dims) 1))
    size = (if (eql dim 0) (arrayLength terms) dim)
    elementType = {
      name: name
      dims: (arraySlice dims 0 (sub (arrayLength dims) 1))
    }
    tuple = (arrayMap term => [elementType term]  terms)
    (if (eql dim 0)
      (bytesConcat
        (encodeUint256 (u16ToBig size))
        (encode 1 tuple))
      (encode 1 tuple))

  (if isTuple
    (encodeTuple args)
    type = (get args "0")
    term = (get args "1")
    dims = (get type "dims")
    (if (arrayLength dims)
      (encodeArray type term)
      (encodeTerm type term)))

decToBig = zb2rhnKgZ66iwb9AGyxTMP6zPbkwxe5jKxrKYTofJqisdhfJU

//(encode 0 [{name:"uint256",dims:[]} (decToBig "69")])
//(encode 0 [{name:"bytes",dims:[]} "0x1234"])
//(encode 1 [
  //[{name:"uint256",dims:[]} (decToBig "69")]
  //[{name:"uint256",dims:[]} (decToBig "1")]
//])
//(encode 0 [{name:"uint256",dims:[0]} [(decToBig "1") (decToBig "2") (decToBig "3")]])





//(isDynamic {name:"bytes",dims:[]})

dims = []
name = "bytes"
(arrayAny (eql 1) [
  (cmp name "string")
  (cmp name "bytes")
  (arrayAny (eql 0) dims)
])






//(encode 1 [
  //[{name:"bytes",dims:[]} "0x64617665"]
  //[{name:"uint256",dims:[]} (decToBig "1")]
  //[{name:"uint256",dims:[0]} [(decToBig "1") (decToBig "2") (decToBig "3")]]
//])


//0x                                                                00000000000000000000000000000000000000000000000000000000000000046461766500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000600000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003
//0x0000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000a0000000000000000000000000000000000000000000000000000000000000000464617665000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000003000000000000000000000000000000000000000000000000000000000000000100000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000003
//baz

//(encodeArray "uint256" 0 [(big "1") (big "2") (big "255")])

        
    







//isDynamic = type =>
  //(or (cmp type "bytes")
  //(or (cmp type "string")
  //(or (cmp type 








//encodeBytes = zb2rhe4m27wnT6An6HCydfKpknyeGBH7GkbPJC5F58Tvg8ZaJ

//(encodeBytes "0xab1299dd36c5ac28d9631112131415161718192200aabbccdd")

// bytes -> [150, 222, 37, ...]
// uint256 -> [185, 54, 48, 66]
// bytes32 -> [185, 54, 48, 66]
// string -> "abvasdfsfafafafdf"

//// (type : String), JSType(type) -> {data: Bytes, dynamic: Bool}
////   ABI-encodes a single term.
//const encode = (type, value) => {
  //if (type === "bytes") {
    //const length = Bytes.length(value);
    //const nextMul32 = (((length - 1) / 32 | 0) + 1) * 32;
    //const lengthEncoded = encodeABI("uint256", Nat.fromNumber(length)).data;
    //const bytesEncoded = Bytes.padRight(nextMul32, value);
    //return {data: Bytes.concat(lengthEncoded, bytesEncoded), dynamic: true};
  //} else if (type === "uint256" || type === "bytes32" || type === "address") {
    //return {data: Bytes.pad(32, value), dynamic: false};
  //} else {
    //throw "Eth-lib can't encode ABI type " + type + " yet.";
  //}
//}

//// (method : Method), [JSType(method.inputs[i].type)] -> Bytes
////   ABI-encodes the transaction data to call a method.
//const methodData = (method, params) => {
  //const methodSig = method.name + "(" + method.inputs.map(i => i.type).join(",") + ")";
  //const methodHash = keccak256s(methodSig).slice(0,10);
  //let encodedParams = params.map((param,i) => encode(method.inputs[i].type, param));
  //var headBlock = "0x";
  //let dataBlock = "0x";
  //for (var i = 0; i < encodedParams.length; ++i) {
    //if (encodedParams[i].dynamic) {
      //var dataLoc = encodedParams.length * 32 + Bytes.length(dataBlock);
      //headBlock = Bytes.concat(headBlock, Bytes.pad(32, Nat.fromNumber(dataLoc)));
      //dataBlock = Bytes.concat(dataBlock, encodedParams[i].data);
    //} else {
      //headBlock = Bytes.concat(headBlock, encodedParams[i].data);
    //}
  //}
  //return Bytes.flatten([methodHash, headBlock, dataBlock]);
//};

