"use strict";

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

// Applies an eta reduction:
// (x => (T x)) => T -- if x isn't free in T

var Synt = require("./moon-syntax");

var nil = function nil(c, n) {
  return n;
};
var cons = function cons(h, t) {
  return function (c, n) {
    return c(h, t(c, n));
  };
};
var conc = function conc(a, b) {
  return function (c, n) {
    return a(c, b(c, n));
  };
};
var bind = function bind(v, a) {
  return function (c, n) {
    return a(function (h, t) {
      return h === v ? t : c(h, t);
    }, n);
  };
};
var free = function free(v, a) {
  return a(function (h, t) {
    return h === v ? 1 : t;
  }, 0);
};
var V = 0,
    A = 1;

var etaReduce = function etaReduce(term) {
  return term({
    App: function App(_ref, _ref2) {
      var _ref4 = _slicedToArray(_ref, 3),
          fv = _ref4[0],
          fm = _ref4[1],
          f = _ref4[2];

      var _ref3 = _slicedToArray(_ref2, 3),
          xv = _ref3[0],
          xm = _ref3[1],
          x = _ref3[2];

      return [conc(fv, xv), xm[0] === V && !free(xm[1], fv) ? [A, f, xm[1]] : [], function (T) {
        return T.App(f(T), x(T));
      }];
    },

    Lam: function Lam(v, _ref5) {
      var _ref6 = _slicedToArray(_ref5, 3),
          bv = _ref6[0],
          bm = _ref6[1],
          b = _ref6[2];

      return [bind(v, bv), bm[0] === A ? [A, function (T) {
        return T.Lam(v, bm[1](T));
      }, bm[2]] : [], bm[0] === A && bm[2] === v ? bm[1] : function (T) {
        return T.Lam(v, b(T));
      }];
    },

    Var: function Var(v) {
      return [cons(v, nil), [V, v], function (T) {
        return T.Var(v);
      }];
    },

    Ref: function Ref(v) {
      return [nil, [], function (T) {
        return T.Ref(v);
      }];
    },

    Let: function Let(v, _ref7, _ref8) {
      var _ref10 = _slicedToArray(_ref7, 3),
          tv = _ref10[0],
          tm = _ref10[1],
          t = _ref10[2];

      var _ref9 = _slicedToArray(_ref8, 3),
          bv = _ref9[0],
          bm = _ref9[1],
          b = _ref9[2];

      return [conc(tv, bind(v, bv)), [], function (T) {
        return T.Let(v, t(T), b(T));
      }];
    },

    Fix: function Fix(v, _ref11) {
      var _ref12 = _slicedToArray(_ref11, 3),
          bv = _ref12[0],
          bm = _ref12[1],
          b = _ref12[2];

      return [bind(v, bv), [], function (T) {
        return T.Fix(b(T));
      }];
    },

    Pri: function Pri(op, args) {
      return [args.reduce(function (v, _ref13) {
        var _ref14 = _slicedToArray(_ref13, 3),
            av = _ref14[0],
            am = _ref14[1],
            a = _ref14[2];

        return conc(av, v);
      }, nil), [], function (T) {
        return T.Pri(op, args.map(function (_ref15) {
          var _ref16 = _slicedToArray(_ref15, 3),
              av = _ref16[0],
              am = _ref16[1],
              a = _ref16[2];

          return a(T);
        }));
      }];
    },

    Num: function Num(num) {
      return [nil, [], function (T) {
        return T.Num(num);
      }];
    },

    Str: function Str(str) {
      return [nil, [], function (T) {
        return T.Str(str);
      }];
    },

    Map: function Map(kvs) {
      return [kvs.reduce(function (v, _ref17) {
        var _ref18 = _slicedToArray(_ref17, 2),
            k = _ref18[0],
            _ref18$ = _slicedToArray(_ref18[1], 3),
            xv = _ref18$[0],
            xm = _ref18$[1],
            x = _ref18$[2];

        return conc(xv, v);
      }, nil), [], function (T) {
        return T.Map(kvs.map(function (_ref19) {
          var _ref20 = _slicedToArray(_ref19, 2),
              k = _ref20[0],
              _ref20$ = _slicedToArray(_ref20[1], 3),
              xv = _ref20$[0],
              xm = _ref20$[1],
              x = _ref20$[2];

          return [k, x(T)];
        }));
      }];
    }

  })[2];
};

var t = Synt.termFromString("\n(get {\n  get: zb2rhjfCUgfysNDVs2pTuMw9Um8hRbGyYdsjKCaMTceKAGDSG\n  len: zb2rhj31DmWEQi2c9stdR1r8wfFboPeFCEdXNysWKikEx3QHy\n  ifoldl: zb2rhXGcmKQVvCtxws32SbxXXifiXTiRcvey35VzptSDBKcog\n  ifoldr: zb2rhXLdKusfYqBUMf1PTKp29ZZdEgV6GWftDBFBrr7EssWFj\n  foldl: zb2rhjnAzkjkikNcjbZkYHf9fobZ6CUgURzNcr2HEEs9fYDRu\n  foldr: zb2rhm3gQLzX2mYD1MVzxC3fGddhGX4dvkhUFeTN9k3fsA48J\n  zipWith: zb2rhhSkBSHtVk6dNL1kw3qcf2nrdyYfqpUCqbVqXC4ewcUyP\n  generate: zb2rhgaF7EwthQmhaMMqTA5XZZJQyKbCzgRqKEKYHvC6ZXYJV\n  map: zb2rhXAGWV4CvSjMCzinpPvsvPSbPCUjah4YKGdfhx5BgbjPK\n  concat: zb2rhcbAzJTfU5R9mT499fiywCCS8MhYP8NEyxxUvu4DMfCg6\n  flatten: zb2rhjeLWGCyUFLwN2dTtSZ99uzD88e1shnudCyZz1E1G3JeV\n  flatMap: zb2rhjQmx5Yp37eqqKzY9Zkb7gjUpw5cDYLhyfUTtTUx7ek2A\n  reverse: zb2rhbtyXTUvLPqAkw8tzfkEvprcUnfsUekR99aV9jj8KVvAT\n  range: zb2rhmAtdKxAfhcH1t2H3qJosFTtrEeVFRmncuefcNdjN3uYf\n  toList: zb2rhiENzFsgXby26Tphue619TMGsjcagqi1ncVf97Yz8xHYZ\n  join: zb2rhkJRCAqHZNwpn7QPuKhR8RV9Z8HHebR6nH3Q7ocBxQ7L5\n  sum: zb2rhjR6Xwheqn5rUyY1zv7Vh3JkHm1VnJr5RPWyJqbUP7G27\n  dot: zb2rhcdsVRwBw7cbTAtiPGKAPphw9zdbqpUqLAaYohfYbtnx6\n  crossWith: zb2rhitmfHXbgKpUQSzrptEWxoimbUJr1wmXQZ2EwxpqVXGsM\n})");

console.log(Synt.termToString(etaReduce(t)));

module.exports = etaReduce;